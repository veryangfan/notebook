# HTTPS协议概述
## 1. 不加密的情况下（明文传输）
在明文传输的情况下，服务端与客户端之间的信息都以明文的方式进行传输，这时候如果出现黑客对数据进行拦截，那么用户名密码等信息将被盗取，这显然是不合理的。  

![图片说明](https://uploadfiles.nowcoder.com/images/20191107/303744_1573130877113_32C75206283F1BACB102A5E486E3CC85 "图片标题")   

## 2. 对称加密
首先来说一下什么叫做对称加密。
首先假设有一个算法法f1(.),加密的密钥为k,加密的数据data,经过加密后，可以得到一段密文x=f1(k,data);同时存在一个解密算法f2(.),可以对密文进行解密还原data=f2(k,x)。这就是对称加密。
那么采用对称加密后，客户端向服务端发送一段密文x1,服务端收到后进行解密得到data1,再向客户端返回一段密文x2，客户端得到x2后进行解密，得到数据data2。传输过程中即使被黑客拦截，黑客也无法获取信息。  

![图片说明](https://uploadfiles.nowcoder.com/images/20191107/303744_1573131645237_1CA763D1DBDAC979496391B11154F0DF "图片标题")    

这样是不是就安全了呢，理论上是的，但实际情况有所不同。由于服务端制定密钥k时，无法确定究竟有多少个客户端，所以无法为每个客户端量身制定一个密钥k，否则如果有一亿个客户端，服务端存储一亿个key，数据量太大也不合理。所以只能制定一个k。如果只有一个k，那么黑客只需要以普通身份访问服务端，就可以拿到这个通用的k，同理也可以得到加密解密算法。最终又不安全了，加密就等于没加密。

## 3. 非对称加密
假设有一个算法f(*),加密的公钥为pk,加密的数据data,经过加密后，可以得到一段密文y=f(pk,data);同时,解密的私钥为sk，可以对密文进行解密还原data=f2(k,y)。若使用私钥进行加密y'=f(sk,data),公钥也可以进行解密data=f(pk,y')。简单来说就是：公钥加密，私钥可以解密；私钥加密，公钥也可以解密。这就是非对称加密。
现在将这个过程在HTTP中进行应用。首先，公钥pk和私钥sk由服务端进行制定，则通信过程中，第一步是服务端向客户端发起请求，索要公钥pk，服务端收到请求后，将pk传输给服务端。第二步，客户端使用公钥进行加密传输y=f(pk，data),服务端收到后进行解密data=f(sk，data)。在这个过程中，公钥所有人都可以有，私钥只有服务端有。所以黑客即使拦截了服务端向客户端发送的信息y，没有私钥sk也无法对其解密。  

![图片说明](https://uploadfiles.nowcoder.com/images/20191107/303744_1573133074036_65F5074A24620EF32562AB1331F616A4 "图片标题") 

这个过程看似完美，实际上有一个致命的缺点，就是服务端如何向客户端发送数据呢？首先肯定是不能使用公钥加密了，因为公钥加密需要私钥解密，客户端没有私钥。那么使用私钥加密呢？如果使用私钥加密，那么在这个过程中，黑客对这个数据拦截，因为黑客也可以拿到公钥pk，所以轻松破译。所以非对称加密也不可取。
![图片说明](https://uploadfiles.nowcoder.com/images/20191107/303744_1573133355568_A65E35AF65F335753FB8BF56BB38A852 "图片标题") 

## 4. 灵感：对称 + 非对称
回头看一下对称加密和非对称加密的特点，想办法将两者结合起来，数学家们想到了一个办法。首先，利用非对称加密的方式，在服务端和客户端之间进行协商，协商出一个临时制定的k，然后再使用这个k进行对称加密，就可以实现每个客户端有一个不同的k了，从而进行信息的交互。
第一步，还是客户端索要公钥pk，服务端发送pk给客户端。第二步，客户端生成一个序列num1，使用pk进行加密y，发送给服务端,服务端使用私钥解密，得到num1，服务端再向客户端发送一个ok。从这一刻起，服务端与客户端的交互将采用对称加密的方式，密钥为num1。![图片说明](https://uploadfiles.nowcoder.com/images/20191107/303744_1573134532087_3367B1D1490D6A6FCFC219F9F1DD05D6 "图片标题") 

又是貌似无懈可击，可是黑客还是有办法。首先，黑客在第一步索要公钥时就已经接入了，黑客自己也准备了一个公钥pk'和一个私钥sk'。当客户端发起索要公钥的请求时，黑客将pk'返回给客户端，同时自己像服务端发起一个索要公钥的请求，得到真正的公钥pk。第二步，客户端生成一个序列num1，使用pk'进行加密得到yy，进行传输，黑客拦截通过sk'解密得到num1,并向客户端发送ok；同时黑客又将num1使用pk进行加密后发送给服务端，服务端给客户端发送ok。之后就开始使用对称加密了，黑客一直充当中间人，但可以拿到所有的数据了。
![图片说明](https://uploadfiles.nowcoder.com/images/20191107/303744_1573135721796_28D1E19481FA2A3D9564FBEEB4119CA2 "图片标题") 

这种加密方式面临一个最大的问题是：**中间人问题**。

>小结：
- 明文=裸奔；
- 对称：唯一key问题；
- 非对称：s->c无法加密
- 对称+非对称：中间人问题
结论：黑客NB


## 4. 引入CA：对称+非对称+CA
引入[CA机构](https://baike.baidu.com/item/CA%E8%AE%A4%E8%AF%81/6471579?fr=aladdin)，只有经过CA认证的公钥才认为是好的公钥。
CA计够也是又公钥cpk和密钥csk的。首先，在服务端使用csk对于pk进行加密，得到一个证书
license=f(csk,pk),客户端不再请求pk了，只请求一个licence，使用cpk进行解密就可以得到pk了。cpk去哪拿呢？如果去找CA机构要，又可能被拦截，干脆不拿了。客户端不去CA机构找cpk，因为cpk已经被写死在客户端的操作系统里了，客户端直接解密就可以了。后面就和前面一样了。
这个过程中，生成license=f(csk,pk)这步是在CA端完成的，所以CA颁发证书通常是需要付费的。
![图片说明](https://uploadfiles.nowcoder.com/images/20191107/303744_1573136714096_665A01211A183BF84EB35FF595F0992C "图片标题") 
我们再来看黑客介入的过程。如果黑客对请求license的过程进行拦截，那么他生成的license是没有经过认证的，返回给客户端解析的过程中会发现是不安全的，则浏览器会弹出红色警告，证书不安全。如果在第二步进行接入，黑客对于加密的y没有私钥进行解密，是无能为力的。
## 5. 生成密钥k的过程
上面对于k生成的过程讲解的比较粗糙，下面来看一下具体过程。
- （1）c->s,携带信息包括SSL版本，非对称算法，随机数1
- （2）s->c, 确定下来SSL版本为1.0，对称算法，随机数2，证书
- （3）c证书认证？成功
- （4）c->s,随机数3，hash（1，2）=xx
- （5）s，xx=hash(1,2)？通过随机数1，2，3生成-->k
- （6）s->c ,hash(1,2,4)=zz
- （7）c，hash(1,2,4)=zz？通过随机1，2，3生成->k


## 总结
HTTPS使用了 **对称加密+非对称加密+hash+CA认证**


