# HTTP协议历史概述


### HTTP/0.9（1991年）
此时比较简单，只有简单的et->file
### HTTP/1.0（1996年）
和我们现在的HTTP已经差不多了。包括请求头+请求体、响应头+响应体。get、post...等请求方式。但是此时的HTTP每次请求需要建立一个连接，请求结束断开连接，下个请求再建立一个新连接，连接复用率不高，影响传输效率。
### HTTP/1.1（1997年）
在请求头中加入了一个connection,默认值为keepalive，在请求结束后，连接保留一段时间，如果在这段时间内还有请求发送到服务器，同样使用这个连接，这样就避免了连接频繁的建立和关闭，提高了效率。这就是我们现在使用的HTTP协议。
如果传输三个数据，只需要建立一个连接
![图片说明](https://uploadfiles.nowcoder.com/images/20191104/303744_1572833992756_781E2F58603151592F968B395FD70094 "图片标题") 

>此时存在一个问题，为什么不能建立三个连接，并行发送三个请求呢？

![图片说明](https://uploadfiles.nowcoder.com/images/20191104/303744_1572834022070_E1308C5C39A23F39D2E48F12D3F5E43A "图片标题") 

这是可以的，HTTP1.1规定了是可以向一个服务器同时并行发送多个请求的，单并行连接的数量是有上限的，连接数不是越多越好，连接过多会导致浏览器负载过重。目前Chrome最多向同一个域名下的请求支持最多六个。
比如说现在有12个请求，就会建立6个连接，先并行传输6个，再并行传输6个。

![图片说明](https://uploadfiles.nowcoder.com/images/20191104/303744_1572834062753_BB4FF17C7E402EA44B01AD890BD3875A "图片标题") 


### HTTP/2.0 （2015）
HTTP1.1协议还存在很多问题：1.明文传输 2. 传输问题 3.header太长 4.sever无法进行主动push(可以通过websocket进行缓解)

1. 不再使用明文传输，对其进行压缩，使用二进制进行传输；
2. 借鉴bt下载的思想，文件块，先打散传输，在重组。使用 **单连接+帧** 的方式进行传输；
3. 对请求头进行了压缩；
4. 服务端可以主动push了，单个请求可以有多个返回；

### HTTP/3.0 （2019）
由基于TCP 转成 UDP,目前还没有制定完全，可能会在2019年底发布。


### 测试HTTP/1.1和HTTP/2.0 [（测试站点）](https://http2.akamai.com/demo)
![图片说明](https://uploadfiles.nowcoder.com/images/20191104/303744_1572834082842_1AA58DDC043F9D21A73DB9EABC9E7FBE "图片标题") 
