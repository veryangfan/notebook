# 原子性与可见性

# 可见性
java内存模型规定，将java的内存分为主内存和工作内存。所有的变量都放在主内存中，当线程使用变量时，会把主内存中的变量复制到工作内存中，然后对工作内存中的变量进行处理，处理完后更新到主内存。  
由此出现了内存不可见的问题。

## volatile关键字
加锁是可以保证内存的可见性的，因为加锁和释放锁的内存语义就是，当获取锁时，先清空工作内存中的变量，直接去主内存中获取；在释放锁时，将本地内存中修改的变量刷新回主内存中。

当一个变量使用volatile关键字修饰时，线程在写入变量时，不会把值存在缓存或者寄存器当中，而是会直接刷新回主内存；当其他线程在读取该共享变量时，也不会读取工作内存中的值，而是直接从主内存中获取。

volatile保证了可见性，但不保证原子性。比如计算一个数值，依赖于当前可见的变量，则需要获取--计算--写入，这三步不是原子性的。

## 原子性

所以怎么保证原子性呢？加锁是可以解决的，因为加锁后可以保证一次只有一个线程操作，但独占锁大大降低了并发性。

所以引入了CAS操作，CAS即Compare and Swap，比较和交换。它是JDK提供的非阻塞原子性操作，通过硬件保证了 比较-更新 操作的原子性。


AtomicLong就是基于CAS实现的。  
