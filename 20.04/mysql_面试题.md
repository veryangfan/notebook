# MySQL面试题目整理

# MyISAM和InnoDB
>两种常见的存储引擎，是表级别的，形容某一张表的
1. InnoDB支持`事物`，而MyISAM不支持事物
2. InnoDB支持`行级锁`，而MyISAM支持`表级锁`
3. InnoDB支持`外键`，而MyISAM不支持
4. InnoDB不支持`全文索引`，而MyISAM支持。

# 什么是事务
事务就是一组原子性的SQL查询。事务内的语句，要么全部执行成功，要么全部执行失败，不可能只成功一部分。
# 事务的特性
ACID  原子性、一致性、隔离性 、持久性

`原子性automicity`：一个事务必须被视为一个不可分割的最小工作单元，整个事务的所有操作，要么全部成功，要么全部失败回滚，不可能只执行其中的一部分操作，这就是事务的原子性。
`一致性consistency`：事务的执行的前后数据的完整性保持一致。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。  
`隔离性isolation`：一个事务所做的修改在最终提交前，对其他事物是不可见的。当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。  
`持久性durability`：一旦事务提交，则其所做的操作就会永久保存到数据库中。


# 四种事务的隔离级别
（1）四种隔离级别
- 读未提交(read uncommitted)
- 读已提交(read committed)
- 可重复读(repeatable read)【MySQL默认】
- 串行(serializable)

（2）现象
1. `脏读：`事务1开始后未提交，事务2读到了这些未提交的数据，读未提交会导致这种现象。
2. `不可重复读：`同一事务先后两次查询某一行数据，可能会有不同结果（后一次查询时，已经被修改/删除），上述12都会造成这种。
3. `幻读：`同一事务先后两次查询出的结果集，因为另一个事务insert导致数据集变化。123都可以出现这种现象。

[四种事务的隔离级别-高性能MySQL](https://note.obs.cn-north-4.myhuaweicloud.com/%E4%BA%8B%E5%8A%A1%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png)

# 事务传播机制


类型|说明
---|:--
propagation_requierd|如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择(MySQL默认)。
propagation_supports|支持当前事务，如果没有当前事务，就以非事务方法执行。
propagation_mandatory|使用当前事务，如果没有当前事务，就抛出异常。
propagation_required_new|新建事务，如果当前存在事务，把当前事务挂起。
propagation_not_supported|以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
propagation_never|以非事务方式执行操作，如果当前事务存在则抛出异常。
propagation_nested|如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作

**注意：MySQL默认的是 PROPAGATION_REQUIRED**

# 索引
索引的底层存储结构是B+树。

普通索引允许重复，唯一索引不允许重复。主键是一种特殊的唯一索引，一个表只能有一个主键。

联合索引生效原则（最左匹配原则）： 从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用；


