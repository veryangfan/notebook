# MySQL面试题目整理

# MyISAM和InnoDB的区别
>两种常见的存储引擎，是表级别的，形容某一张表的
1. InnoDB支持`事物`，而MyISAM不支持事物
2. InnoDB支持`行级锁`，而MyISAM支持`表级锁`
--以上两点尤其重要--

3. InnoDB支持`外键`，而MyISAM不支持
4. InnoDB不支持`全文索引`，而MyISAM支持。


MyISAM 操作数据都是使用的表锁，你更新一条记录就要锁整个表，导致性能较低，并发不高。当然同时它也不会存在死锁问题。

而 InnoDB 与 MyISAM 的最大不同有两点：一是 InnoDB支持事务；二是 InnoDB 采用了行级锁。也就是你需要修改哪行，就可以只锁定哪行。

在 Mysql 中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，Mysql 就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。

InnoDB 行锁是通过给索引项加锁实现的，如果没有索引，InnoDB会通过隐藏的聚簇索引来对记录加锁。也就是说：如果不通过索引条件检索数据，那么InnoDB将对表中所有数据加锁，实际效果跟表锁一样。因为没有了索引，找到某一条记录就得扫描全表，要扫描全表，就得锁定表。


# 什么是事务
事务就是一组原子性的SQL查询。事务内的语句，要么全部执行成功，要么全部执行失败，不可能只成功一部分。
# 事务的特性
ACID  原子性、一致性、隔离性 、持久性

`原子性automicity`：一个事务必须被视为一个不可分割的最小工作单元，整个事务的所有操作，要么全部成功，要么全部失败回滚，不可能只执行其中的一部分操作，这就是事务的原子性。  
`一致性consistency`：事务的执行的前后数据的完整性保持一致。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。  
`隔离性isolation`：一个事务所做的修改在最终提交前，对其他事务是不可见的。当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。  
`持久性durability`：一旦事务提交，则其所做的操作就会永久保存到数据库中。


# 四种事务的隔离级别
（1）四种隔离级别
- 读未提交(read uncommitted)
- 读已提交(read committed)
- 可重复读(repeatable read)【MySQL默认】
- 串行(serializable)

（2）现象
1. `脏读：`事务1开始后未提交，事务2读到了这些未提交的数据，读未提交会导致这种现象。
2. `不可重复读：`同一事务先后两次查询某一行数据，可能会有不同结果（后一次查询时，已经被修改/删除），上述12都会造成这种。
3. `幻读：`同一事务先后两次查询出的结果集，因为另一个事务insert导致数据集变化。123都可以出现这种现象。

![现象](https://note.obs.cn-north-4.myhuaweicloud.com/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%8E%B0%E8%B1%A1.jpg)

[四种事务的隔离级别-高性能MySQL](https://note.obs.cn-north-4.myhuaweicloud.com/%E4%BA%8B%E5%8A%A1%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png)

# 事务传播机制


类型|说明
---|:--
propagation_requierd|如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择(MySQL默认)。
propagation_supports|支持当前事务，如果没有当前事务，就以非事务方法执行。
propagation_mandatory|使用当前事务，如果没有当前事务，就抛出异常。
propagation_required_new|新建事务，如果当前存在事务，把当前事务挂起。
propagation_not_supported|以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
propagation_never|以非事务方式执行操作，如果当前事务存在则抛出异常。
propagation_nested|如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作

**注意：MySQL默认的是 PROPAGATION_REQUIRED**

# 索引

在MySQL里常用的索引数据结构有B+树索引和哈希索引两种。

B+树索引和哈希索引的明显区别是：

- 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；

- 如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；

- 同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；

- 哈希索引也不支持多列联合索引的最左匹配规则；

- B+树索引的关键字检索效率比较平均，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。

普通索引允许重复，唯一索引不允许重复。主键是一种特殊的唯一索引，一个表只能有一个主键。

联合索引生效原则（最左匹配原则）： 从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用；