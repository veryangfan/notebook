# 锁 & 同步
Java提供了两种类型的锁，来控制多个线程对于共享资源的访问。
1. 一个是 JVM 实现的, `synchronized`，
2. 另一个是 JDK 实现的,Lock接口的具体实现 `ReentrantLock`


## synchonized 同步关键字
3种用法
1）用于同步一个代码块  
2）用于同步一个方法  
3）用于同步一个类  

1和2其实没有本质区别，都是只能作用于同一个对象  
3因为将整个类都同步了，所以可以作用于多个对象  

## ReentrantLock

ReentrantLock是可重入的独占锁

两者比较：
1. synchonized是关键字，而ReentrantLock是类；
2. synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。
3. synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。
4. Lock实际上有一些高级的性能，比如tryLock（避免线程阻塞），可以绑定多个Condition对象


## ReadWriteLock读写锁
ReadWriteLock是一个读写锁的接口，ReentrantReadWriteLock是其一个具体实现，实现了读写的分离，**读锁是共享的，写锁是独占的**，这样读与读之间就不会发生互斥，读写、写读、写写之间才会发生互斥。


# 各种类型锁的定义
## 1.乐观锁与悲观锁
悲观锁认为数据很容易被其他线程修改，所以在数据整个过程中进行加锁，使数据处于阻塞状态。
乐观锁认为数据在一般情况下不会产生冲突，所以在记录前不会加排他锁，而是在数据提交更新时，检测数据是否产生了变化。如果产生了变化，则重新获取再更新。

## 2.公平锁与非公平锁
根据抢占机制划分。公平锁是先到先得；非公平锁则是根据线程调度策略，先到不一定先得。
在没有公平需求的情况下，尽量使用非公平锁，公平锁会增大开销。

```java
//ReentrantLock提供了公平锁与非公平锁的实现

ReentrantLock lock = new ReentrantLock(true); //公平

ReentrantLock lock = new ReentrantLock(false); //非公平，默认
```
## 3.独占锁与共享锁
独占锁任何时候都保证只有一个线程可以得到，如ReentrantLock，ReadWriteLock的写锁  
共享锁可以同时由多个线程持有，ReadWriteLock的读锁  

## 4.可重入锁
当一个线程再次获取它已经获得的锁，如果不被阻塞，则可以说是可重入锁。
synchonized和ReentrantLock都是可重入锁。可重入锁的原理是在锁的内部维护了一个线程标志位--标志当前锁被哪个线程获取的，然后再关联一个计数器。当锁被获取时，计数器+1。此时另一个线程来获取锁，发现拥有者不是自己则阻塞；当原来的线程再次获取锁时，发现拥有者是自己，则计数器再+1，释放锁后，则计数器-1。当计数器为0时，线程标志位置为null，这是被阻塞的线程就回来竞争锁。

## 5. 自旋锁

线程自己旋转重复多次尝试获取该锁。

当前线程在获取锁时，发现锁已经被其他线程占有，并不马上阻塞自己，而是多次尝试获取，达到一次失败次数（通常是10次）后，再阻塞挂起。


